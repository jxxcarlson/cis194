module Brownian where

{-

Module for computing the paths generated by Brownian motion.
This is intended to be part of a later art project.
The next step is to make a render-to-SVG function.

-}


import Control.Monad.Random


-- 1D Brownian path of length n
path :: RandomGen g => Int -> Rand g [Double]
path n = liftA2 (scanl (+)) (step) (steps n)

-- 2D Brownian path of length n
path2D :: RandomGen g => Int -> Rand g [(Double, Double)]
path2D n = liftA2 (scanl addPair) (step2D) (steps2D n)

-- DEMO --

-- type 'main' in ghci
main = do
    moves <- evalRandIO $ path2D 10
    print moves


-- HELPERS --

step :: RandomGen g => Rand g Double
step = getRandomR (-1,1)

liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
liftA2 h fa fb = h <$> fa <*> fb

step2D :: RandomGen g => Rand g (Double, Double)
step2D = liftA2 (,) (getRandomR (-1,1)) (getRandomR (-1,1))

steps :: RandomGen g => Int -> Rand g [Double]
steps n = sequence (replicate n step)



steps2D :: RandomGen g => Int -> Rand g [(Double, Double)]
steps2D n = sequence (replicate n step2D)

addPair :: (Double, Double) -> (Double, Double) -> (Double, Double)
addPair (x,y) (x', y') = (x + x', y + y')


